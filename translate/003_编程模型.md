# 3. 编程模型 (Programmers Model)

该章节将介绍处理器编程模型。包含以下部分：

- 关于编程模型
- 操作模式和执行模式
- 指令集
- 系统地址映射
- 写缓冲区 (Write buffer)
- 位带 (Bit-banding)
- 处理器核心寄存器
- 异常



## 3.1. 关于编程模型 (About the programmers model)

**ARMv7-M Architecture Reference Manual** 中对编程模型进行完整的解释。本章概述实现定义选项的 Cortex-M3 处理器的程序模型。也包含 ARMv7-M Thumb 指令的使用和指令执行的周期。此外：

- 第四章节概述编程模型的系统控制特点。
- 第五章节概述编程模型的 MPU 特点。
- 第六章节概述编程模型的 NVIC 特点。
- 第七章节概述编程模型的 Debug 特点。
- 第八章节概述编程模型的 DWT 特点。
- 第九章节概述编程模型的 ITM 特点。
- 第十章节概述编程模型的 ETM 特点。
- 第十一章节概述编程模型的 TPIU 特点。



## 3.2. 操作模式和执行模式 (Modes of operation and execution)

该节简单描述 Cortex-M3 处理器的操作模式和执行模式。详见 **ARMv7-M Architecture Reference Manual** 。



### 3.2.1. 操作模式 (Operation modes)

处理器支持两种操作模式，分别为 **Thread** 模式 和 **Handler** 模式：

- 处理器在复位后，或异常返回后进入 **Thread** 模式。特权和用户代码都可以运行在 **Thread** 模式。
- 处理器在发生异常时进入 **Handler** 模式。在 **Handler** 模式中只能运行特权代码。



### 3.2.2.  操作状态 (Operating states)

处理器可以在以下两种状态中操作：

- **Thumb 状态**：用于正常执行 16-bit 和 32-bit 半字对齐的 **Thumb** 指令。
- **Debug 状态**：用于调试时停止处理器。



### 3.2.3. 特权访问和用户访问 (Privileged access and user access)

代码可以作为特权和非特权执行。非特权执行有一些限制或排除对某些资源的访问。特权执行可以访问所有资源。**Handler** 模式总是特权执行。**Thread** 模式可以是特权或非特权执行。



## 3.3. 指令集 (Instruction set summary)

分以下几点进行阐述：

- Cortex-M3 指令
- Load/store timings
- 与其它 Cortex 处理器的二进制兼容 (Binary compatibility with other Cortex processors)



### 3.3.1. Cortex-M3 指令 (Cortex-M3 instructions)

处理器实现了 ARMv7-M Thumb 指令集。下表 3-1 列出了 Cortex-M3 指令和各自的周期计数 (cycle counts)。周期计数基于系统处于零延时状态 (即理论值)。



汇编程序的语法中，是依赖于操作符，**\<op2>** 域可能会被以下选项中的任一种代替：

- 一个寄存器指示符，如：**Rm**
- 一个立即移位寄存器 (an immediate shifted register)，如：Rm, LSL #4
- 一个寄存器移位寄存器 (a register shifted register)，如： Rm, LSL Rs
- 一个立即数 (immediate value)，如：#0xE000E000



简单起见，并没有将所有的 load 和 store 地址模式全部显示。更多信息详见 **ARMv7-M Architecture Reference Manual** 。



表 3-1 周期列中的缩写含义如下：

| 值   | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| P    | 流水线再次填充所需要的周期数。依赖目标指令的宽度和对齐，以及处理器是否能够尽早推测出地址，范围为 1~3。 |
| B    | 执行屏蔽操作 (barrier operation) 所需要的周期数。对 DSB 和 DMB，最小周期数为 0。对于 ISB，最小周期数等于流水线再次填充所需要的周期数。 |
| N    | 要被加载或存储 (loaded or stored) 的寄存器列表中寄存器的个数，包括 PC 或 LR。 |
| W    | 等待适当事件所花费的周期数。                                 |
| a    | UMULL, SMULL, UMLAL 和 SMLAL 指令根据原始值大小使用提前终止。这些都是可中断的，被丢弃和重新启动的，最坏的情况下延迟一个周期。 |
| b    | 除法操作使用提前终止来根据输入操作数中的前导 1 和 0 的个数最小化所需的周期数。 |
| c    | 相邻的加载和存储单个指令可以通过管道 (pipeline) 传输它们的地址和数据阶段。他使这些指令能够在一个执行周期内完成。 |
| d    | 如果不接受条件分支，则条件分支将在一个周期内完成。           |
| e    | 可以将 IT 指令折叠到前面的 16-bit 的 Thumb 指令上，使其在 0 周期执行。 |



**表3-1 Cortex-M3 指令集**

| 操作码       | 类型                     | 汇编指令                    | 周期计数    |
| ------------ | ------------------------ | --------------------------- | ----------- |
| Move         | Register                 | MOV Rd, \<op2>              | 1           |
|              | 16-bit immediate         | MOVW Rd, #\<imm>            | 1           |
|              | Immediate into top       | MOVT Rd, #\<imm>            | 1           |
|              | To PC                    | MOV PC, Rm                  | 1 + P       |
| Add          | Add                      | ADD Rd, Rn, \<op2>          | 1           |
|              | Add to PC                | ADD PC, PC, Rm              | 1 + P       |
|              | Add with carry           | ADC Rd, Rn, \<op2>          | 1           |
|              | Form address             | ADR Rd, \<label>            | 1           |
| Subtract     | Subtract                 | SUB Rd, Rn, \<op2>          | 1           |
|              | Subtract with borrow     | SBC Rd, Rn, \<op2>          | 1           |
|              | Reverse                  | RSB Rd, Rn, \<op2>          | 1           |
| Multiply     | Multiply                 | MUL Rd, Rn, Rm              | 1           |
|              | Multiply accumulate      | MLA Rd, Rn, Rm              | 2           |
|              | Multiply subtract        | MLS Rd, Rn, Rm              | 2           |
|              | Long signed              | SMULL RdLo, RdHi, Rn, Rm    | 3 ~ 5a      |
|              | Long unsigned            | UMULL RdLo, RdHi, Rn, Rm    | 3 ~ 5a      |
|              | Long signed accumulate   | SMLAL RdLo, RdHi, Rn, Rm    | 4 ~ 7a      |
|              | Long unsigend accumulate | UMLAL RdLo, RdHi, Rn, Rm    | 4 ~ 7a      |
| Divide       | Signed                   | SDIV Rd, Rn, Rm             | 2 ~ 12b     |
|              | Unsigned                 | UDIV Rd, Rn, Rm             | 2 ~ 12b     |
| Saturate     | Signed                   | SSAT Rd, #\<imm>, \<op2>    | 1           |
|              | Unsigned                 | USAT Rd, #\<imm>, \<op2>    | 1           |
| Compare      | Compare                  | CMP Rn, \<op2>              | 1           |
|              | Negative                 | CMN Rn, \<op2>              | 1           |
| Logical      | AND                      | AND Rd, Rn, \<op2>          | 1           |
|              | Exclusive OR             | EOR Rd, Rn, \<op2>          | 1           |
|              | OR                       | ORR Rd, Rn, \<op2>          | 1           |
|              | OR NOT                   | ORN Rd, Rn, \<op2>          | 1           |
|              | Bit clear                | BIC Rd, Rn, \<op2>          | 1           |
|              | Move NOT                 | MVN Rd, \<op2>              | 1           |
|              | AND test                 | TST Rn, \<op2>              | 1           |
|              | Exclusive OR test        | TEQ Rn, \<op1>              |             |
| Shift        | Logical shift left       | LSL Rd, Rn, #\<imm>         | 1           |
|              | Logical shift left       | LSL Rd, Rn, Rs              | 1           |
|              | Logical shift right      | LSR Rd, Rn, #\<imm>         | 1           |
|              | Logical shift right      | LSR Rd, Rn, Rs              | 1           |
|              | Arithmetic shift right   | ASR Rd, Rn, #\<imm>         | 1           |
|              | Arithmetic shift right   | ASR Rd, Rn, Rs              | 1           |
| Rotate       | Rotate right             | ROR Rd, Rn, #\<imm>         | 1           |
|              | Rotate right             | ROR Rd, Rn, Rs              | 1           |
|              | With extension           | RRX Rd, Rn                  | 1           |
| Count        | Leading zeroes           | CLZ Rd, Rn                  | 1           |
| Load         | Word                     | LDR Rd, [Rn, \<op2>]        | 2c          |
|              | To PC                    | LDR PC, [Rn, \<op2>]        | 2c + P      |
|              | Halfword                 | LDRH Rd, [Rn, \<op2>]       | 2c          |
|              | Byte                     | LDRB Rd, [Rn, \<op2>]       | 2c          |
|              | Signed halfword          | LDRSH Rd, [Rn, \<op2>]      | 2c          |
|              | Signed byte              | LDRSB Rd, [Rn, \<op2>]      | 2c          |
|              | User word                | LDRT Rd, [Rn, #\<imm>]      | 2c          |
|              | User halfword            | LDRHT Rd, [Rn, #\<imm>]     | 2c          |
|              | User byte                | LDRBT Rd, [Rn, #\<imm>]     | 2c          |
|              | User signed halfword     | LDRSHT Rd, [Rn, #\<imm>]    | 2c          |
|              | User signed byte         | LDRSBT Rd, [Rn, #\<imm>]    | 2c          |
|              | PC relative              | LDR Rd, [PC, #\<imm>]       | 2c          |
|              | Doubleword               | LDRD Rd, Rd, [Rn, #\<imm>]  | 1 + N       |
|              | Multiple                 | LDM Rn, {\<reglist>}        | 1 + N       |
|              | Multiple including PC    | LDM Rn, {\<reglist>, PC}    | 1 + N + P   |
| Store        | Word                     | STR Rd, [Rn, \<op2>]        | 2c          |
|              | Halfword                 | STRH Rd, [Rn, \<op2>]       | 2c          |
|              | Byte                     | STRB Rd, [Rn, \<op2>]       | 2c          |
|              | Signed halfword          | STRSH Rd, [Rn, \<op2>]      | 2c          |
|              | Signed byte              | STRSB Rd, [Rn, \<op2>]      | 2c          |
|              | User word                | STRT Rd, [Rn, #\<imm>]      | 2c          |
|              | User halfword            | STRHT Rd, [Rn, #\<imm>]     | 2c          |
|              | User byte                | STRBT Rd, [Rn, #\<imm>]     | 2c          |
|              | User signed halfword     | STRSHT Rd, [Rn, #\<imm>]    | 2c          |
|              | User signed byte         | STRSBT Rd, [Rn, #\<imm>]    | 2c          |
|              | Doubleword               | STRD Rd, Rd, [Rn, #\<imm>]  | 1 + N       |
|              | Multiple                 | STM Rn, {\<reglist>}        | 1 + N       |
| Push         | Push                     | PUSH {\<reglist>}           | 1 + N       |
|              | Push with link register  | PUSH {\<register>, LR}      | 1 + N       |
| Pop          | Pop                      | POP {\<register>}           | 1 + N       |
|              | Pop and return           | POP {\<register>, PC}       | 1 + N + P   |
| Semaphore    | Load exclusive           | LDREX Rd, [Rn, #\<imm>]     | 2           |
|              | Load exclusive half      | LDREXH Rd, [Rn]             | 2           |
|              | Load exclusive byte      | LDREXB Rd, [Rn]             | 2           |
|              | Store exclusive          | STREX Rd, Rt, [Rn, #\<imm>] | 2           |
|              | Store exclusive half     | STREXH Rd, Rt, [Rn]         | 2           |
|              | Store exclusive byte     | STREXB Rd, Rt, [Rn]         | 2           |
|              | Clear exclusive monitor  | CLREX                       | 1           |
| Branch       | Conditional              | B\<cc> \<lable>             | 1 or 1 + Pd |
|              | Unconditional            | B \<lable>                  | 1 + P       |
|              | With link                | BL \<label>                 | 1 + P       |
|              | With exchange            | BX Rm                       | 1 + P       |
|              | With link and exchange   | BLX Rm                      | 1 + P       |
|              | Branch if zero           | CBZ Rn, \<label>            | 1 or 1 + Pd |
|              | Branch if non-zero       | CBNZ Rn, \<label>           | 1 or 1 + Pd |
|              | Byte table branch        | TBB [Rn, Rm]                | 2 + P       |
|              | Half table branch        | TBH [Rn, Rm, LSL#1]         | 2 + P       |
| State change | Supervisor call          | SVC #\<imm>                 | -           |
|              | If-then-else             | IT ... \<cond>              | 1e          |
|              | Disable interrupts       | CPSID \<flags>              | 1 or 2      |
|              | Enable interrupts        | CPSIE \<flags>              | 1 or 2      |
|              | Read special register    | MRS Rd, \<specreg>          | 1 or 2      |
|              | Write special register   | MSR \<specreg>, Rn          | 1 or 2      |
|              | Breakpoint               | BKPT #\<imm>                | -           |
| Extend       | Signed halfword to word  | SXTH Rd, \<op2>             | 1           |
|              | Signed byte to word      | SXTB Rd, \<op2>`            | 1           |

| 操作码    | 类型                        | 汇编指令                      | 周期计数 |
| --------- | --------------------------- | ----------------------------- | -------- |
| Extend    | Unsigned halfword           | UXTH Rd, \<op2>               | 1        |
|           | Unsigned byte               | UXTB Rd, \<op2>               | 1        |
| Bit field | Extract unsigned            | UBFX Rd, Rn, #\<imm>, #\<imm> | 1        |
|           | Extract signed              | SBFX Rd, Rn, #\<imm>, #\<imm> | 1        |
|           | Clear                       | BFC Rd, Rn, #\<imm>, #\<imm>  | 1        |
|           | Insert                      | BFI Rd, Rn, #\<imm>, #\<imm>  | 1        |
| Reverse   | Bytes in word               | REV Rd, Rm                    | 1        |
|           | Bytes in both halfwords     | REV16 Rd, Rm                  | 1        |
|           | Signed bottom halfword      | REVSH Rd, Rm                  | 1        |
|           | Bits in word                | RBIT Rd, Rm                   | 1        |
| Hint      | Send event                  | SEV                           | 1        |
|           | Wait for event              | WFE                           | 1 + W    |
|           | Wait for interrupt          | WFI                           | 1 + W    |
|           | No operation                | NOP                           | 1        |
| Barriers  | Instruction synchronization | ISB                           | 1 + B    |
|           | Data memory                 | DMB                           | 1 + B    |
|           | Data synchronization        | DSB \<flags>                  | 1 + B    |



### 3.3.2. 加载/存储计时 (Load/store timings)

以下将描述如何最佳地对指令进行配对，以实现更多的时间缩减：

- **STR Rx, [Ry, #imm]** 总是一个周期，这是因为地址产生是在最初的周期 (initial cycle) 中被执行的，数据存储是在执行下一条指令的同时执行的。如果存储到缓冲区，但缓冲区已满或者没有被使能，则下一条指令将被延迟，直到存储完成。如果不是存储到缓冲区，列如：对于 **Code segment** 和事务停止，只有在完成之前执行另一个加载或存储操作时，才会感觉到对时间的影响。
- **LDR Rx!, [any]** 不是一般的流水线。也就是说，基于更新加载通常至少是2个周期的操作(如果停止，则更多)。但是，如果下一条指令不需要从寄存器中读取，那么加载就会减少到一个周期。非寄存器写指令包括 CMP、TST、NOP 和non-taken IT controlled 指令。
- **LDR PC, [any]** 总是一个阻塞的操作。这意味着至少有两个周期用于加载，三个周期用于流水线重新加载。因此，这个操作至少需要五个周期，如果在加载或取指时阻塞则需要更多。
- **LDR Rx, [PC, #imm]** 可能会由于与取指单元的争用而增加一个周期。
- **TBB 和 TBH** 也是阻塞操作。至少有两个周期用于加载，一个周期用于添加，三个周期用于流水线重新加载。因此，这个操作至少需要六个周期，如果在加载或取指时阻塞则需要更多。
- **LDR [any]** 有可能变成流水线操作。也就是说如果下一条指令是 **LDR or STR** ，第一条 **LDR** 指令的目的将不再用于计算下一条指令的地址，因此，下一条指令将减少一个周期的耗费。一个 **LDR** 后面可能会跟随一个 **STR** ，**STR** 写出 **LDR** 加载的内容。多个 **LDRs** 组在一起形成流水线操作。一些优化示例如下：
  - LDR R0, [R1];	LDR R1, [R2];  通常需要 3 个周期
  - LDR R0, [R1, R2];    STR R0, [R3, #20];  通常需要 3 个周期
  - LDR R0, [R1, R2];     STR R1, [R3, R2];    通常需要 3 个周期
  - LDR R0, [R1, R5];      LDR R1, [R2];    LDR R2, [R3, #4];  通常需要 4 个周期
- 其他指令不能在 **STR** 之后使用寄存器偏移进行流水线操作。**STR** 只有位于 **LDR** 之后才能进行流水线操作。但是在存储之后就不能进行流水线作业了。由于存储缓冲区的原因，即使是阻塞的 **STR** 通常也只需要两个周期。
- **LDREX** 和 **STREX** 可以像 **LDR** 一样进行流水线作业。因为 **STREX** 更像是一个 **LDR** ，它可以像 **LDR** 中解释的那样流水线作业。同样，**LDREX** 也被当作一个 **LDR** 来处理，因此可以流水线作业。
- **LDRD** 和 **STM** 不能通过前面或后面的指令进行流水线作业。然而，这两个字是流水线连接在一起的。因此，如果不阻塞，这个操作需要三个周期。
- **LDM** 和 **STM** 不能通过前面或后面的指令进行流水线作业。然而，第一个元素之后的所有元素都是流水线连在一起的。因此，三个元素的 **LDM** 在没有阻塞时需要 2+1+1 或 5 个周期。同样地，八个元素的存储在没有阻塞时需要 9 个周期。当发生了中断，**LDM** 和 **STM** 指令将从返回的地方继续执行。这种连续的操作将在第一个元素开始的时候添加 1 或 2 个 周期。
- 未对齐的字或半字加载或存储会增加惩罚周期 (penalty cycles)。按字节对齐的半字加载或存储将增加一个额外的周期，以两个字节的形式执行操作。半字对齐的字加载或存储将增加一个额外的周期，以作为两个半字执行操作。字节对齐的字加载或存储会添加两个额外的周期，以字节、半字和字节的形式执行操作。如果内存阻塞，这些周期就会增加。**STR** 或 **STRH** 因为有存储缓冲区，而不会延迟处理器。



### 3.3.3. 与其它 Cortex 处理器的二进制兼容 (Binary compatibility with other Cortex processors)

处理器实现指令集的二进制兼容子集和其他 Cortex-M 配置 (profile) 处理器提供的特性。您可以将软件 (包括系统级软件) 从 Cortex-M3 处理器移动到其他 Cortex-M 配置 (profile) 处理器。



为了平稳过度，ARM 建议那些运行在其它 Cortex-M 配置 (profile) 处理器架构上的代码设计应遵从以下规则，并正确配置配置控制寄存器 (CCR: Configuration Control Register)：

- 只使用字传输访问 **NVIC** 和系统控制空间(SCS: System Control Space)中的寄存器。
- 将处理器上所有未使用的 **SCS** 寄存器和寄存器字段视为不可修改 (Do-Not-Modify)。
- 配置 **CCR** 寄存器中的以下字段：
  - **STKALIGN** 位设置为 1。
  - **UNALIGN_TRP** 位设置为 1.
  - **CCR** 寄存器的其它位全部保留为原始值。



## 3.4. 系统地址映射 (System address map)

处理器包含一个总线矩阵，它仲裁处理器内核和可选调试访问端口 (DAP: Debug Access Port) 内存访问外部内存系统和内部系统控制空间(SCS: System Control Space)和调试组件。



处理器使用优先级以确保任何调试访问都尽可能是非侵入性 (non-intrusive) 的。对于零等待状态系统，对系统内存、SCS 和调试资源的所有调试访问都是完全非侵入性的。

图 3-1 展示了系统内存的映射：

![](E:\Work\ARM\pictures\Chapter 3\Snipaste_2019-07-08_14-29-55.png)

| Memory Map             | Region                                                       |
| ---------------------- | ------------------------------------------------------------ |
| Code                   | 指令取指在 ICode 总线上执行。数据访问在 DCode 总线上执行。   |
| SRAM                   | 指令取指和数据访问在系统总线上执行。                         |
| SRAM bit-band          | 别名区。数据访问是别名。指令访问不是别名。                   |
| Peripheral             | 指令取指和数据访问在系统总线上执行。                         |
| Peripheral bit-band    | 别名区。数据访问是别名。指令访问不是别名。                   |
| External RAM           | 指令取指和数据访问在系统总线上执行。                         |
| External Device        | 指令取指和数据访问在系统总线上执行。                         |
| Private Peripheral Bus | 外部和内部的私有外设总线接口 (PPB: Private Peripheral Bus)。这个区域不能执行 (XN: Execute Never)，禁止指令取指。即使存在 MPU，依然如此。 |
| System                 | 供应商系统外设的系统区域。该区域不能执行 (XN: Execute Never)，禁止指令取指。即使存在 MPU，依然如此。 |



### 3.4.1. 私有外设总线 (Private peripheral bus)

内部的私有外设总线接口 (PPB: Private Peripheral Bus) 提供访问：

- 仪器跟踪宏单元 (ITM: Instrumentation Trace Macrocell)
- 数据观察点和跟踪 (DWT: Data Watcpoint and Trace)
- 闪存补丁和断点 (FPB: Flashpatch and Breakpoint)
- 系统控制空间 (SCS: System Control Space)，包括内存保护单元 (MPU: Memory Protection Unit) 和 嵌套向量中断控制器 (NVIC: Nested Vectored Interrupt Controller)。

外部的 PPB 接口提供访问：

- 跟踪端口接口单元 (TPIU: Trace Port Interface Unit)
- 嵌入式跟踪宏单元 (ETM: Embedded Trace Macrocell)
- ROM 表
- PPB 内存映射的特定于实现的区域。



### 3.4.2. 跨域的非对齐访问 (Unaligned accesses that cross regions)

Cortex-M3 支持 ARMv7 非对齐访问，将所有的访问作为单个，非对齐访问。**DCode** 和 **System** 总线接口将它们转化为两个或多个对齐访问。

**注：所有 Cortex-M3 的外部访问都是对齐的**。



非对齐访问仅对单个加载/存储 (LDR, STR) 有效。双倍加载/存储已经支持字对齐访问，企图使用其它非对齐访问时，则会产生 **fault** 。



跨内存映射边界的非对齐访问在架构上是不可预测的。处理器行为与边界相关，如下：

- DCode 访问域中的内容。如：非半字对齐访问代码区中的最后一个字节 (0x1FFF_FFFF)，则 DCode 总线接口将转化为访问 0x1FFF_FFFF 地址的一个字节和 0x0000_0000 地址的一个字节。
- 跨 PPB 空间的系统访问不会在封装在系统空间内。例如：作为字节访问非半字对齐访问系统空间 (0xDFFF_FFFF)，系统总线接口将转化为 0xDFFFF_FFFF 地址的一个字节和 0xE000_0000 地址的一个字节。0xE000_0000 地址在系统总线上是无效的地址。
- 跨代码空间的系统访问不会封装在系统空间中。例如：作为字节访问非半字对齐访问系统空间的 (0xFFFF_FFFF)，系统总线接口将转化为 0xFFFFF_FFFF 地址的一个字节和 0x0000_0000 地址的一个字节。0x0000_0000 地址在系统总线上是无效的地址。
- 不支持对 PPB 空间的非对齐访问，所以 PPB 访问没有边界交叉的情况。



跨位带别名区域的未对齐访问在体系结构上也是不可预测的。处理器执行访问位带别名区地址，不会导致位带的操作。例如：作为字节访问非半字对齐访问 0x21FF_FFFF 地址，将访问 0x21FF_FFFF  地址的股饿哦字节和 0x2200_0000 (位带别名区的第一个字节)地址的一个字节。



不重新映射 FPB 中与文字比较器匹配的未对齐加载。FPB 只重映射对齐的地址。



## 3.5. 写缓冲区 (Write buffer)

为防止总线等待周期在数据存储期间使处理器停止工作，DCode 和系统总线通过一个单条目写缓冲区将缓冲存储。如果写缓冲区满了，在写缓冲区有空余之前，对总线的后续访问将停止。写入缓冲区仅在总线等待缓冲存储的数据阶段时使用，否则事务将在总线上完成。



**DMB** 和 **DSB** 指令等待写缓冲区完成之后再完成。如果在 **DMB** 或 **DSB** 等待写缓冲区完成时发生中断，

在中断完成后，处理器返回到 **DMB** 或 **DSB** 后面的指令。这是因为中断处理作为一种内存屏障操作。**注：因此在 DMB 或 DSB 隔离时需要关掉中断**。



## 3.6. 独占监视器 (Exclusive monitor)

Cortex-M3 处理器实现了一个本地独占监视器，更多信息详见 **ARMv7M ARM Architecture Reference
Manual** 。



## 3.7. 位带 (Bit-banding)

位带将一个完整的内存字映射到位带区域中的一个位上。例如：在别名区中写入一个字设置或清除位带区域中相应的位。这使得位带区域中的每个位都可以使用一条 LDR 指令从字对齐的地址直接访问。它还允许在不执行读-修改-写指令序列的情况下切换各个位。



处理器内存映射包括两个位带区域。分别为 SRAM 和 Peripheral 内存区域开始的 1MB 空间。这些位带域中的每一个位映射到位带别名区的每一个字。



系统总线接口包含控制位带访问的逻辑，如下：

- 它将位带别名地址重新映射到位带区域。
- 对于读取，它从读取字节中提取请求的位，并返回读数据的最低有效位返回给内核。
- 对于写入，它将写转换为原子的读-修改-写操作。
- 在位带操作期间，除非试图同时在系统总线上进行位带操作访问，否则，处理器不会被阻塞。

内存映射有 2 个32MB 的别名区域，它们分别映射到 2 个MB 的位带区域。

- 访问 32MB 的 SRAM 别名区映射到 1MB 的 SRAM 位带区。
- 访问 32MB 的 Peripheral 别名区映射到 1MB 的 Peripheral 位带区。



映射公式显示如何将别名区域中的每个字对应到位带区的每一个位，公式如下：

bit_word_offset = (byte_offset * 32) + (bit_number * 4)

bit_word_addr = bit_band_base + bit_word_offset

bit_word_offset：表示目标 bit 位在位带域中的位置。

bit_word_addr： 映射到目标 bit 位对应的别名区中字的地址。

bit_band_base：别名区的起始地址。

bit_number：目标 bit 位的位置， 0 ~ 7。



如下图 3-2 中显示了别名区与位带区地址对应关系：

![](E:\Work\ARM\pictures\Chapter 3\Snipaste_2019-07-08_17-16-04.png)



- 别名区 0x23FF_FFE0 映射到 位带区 0x200F_FFFF 的 bit[0] 位。0x23FF_FFE0 = 0x2200_0000 + (0xF_FFFF * 32) + 0 * 4。
- 别名区 0x23FF_FFFFC 映射到位带区 0x200F_FFFF 的 bit[7] 位。0x23FF_FFFFC = 0x2200_0000 + (0xF_FFFF * 32) + 7 * 4。
- 别名区 0x2200_0000 映射到位带区 0x2000_0000 的 bit[0] 位。0x2200_0000 = 0x2200_0000 + (0x0 * 32) + 0 * 4。
- 别名区 0x2200_001C 映射到位带区 0x2000_0000 的 bit[7] 位。0x2200_001C = 0x2200_0000 + (0x0 * 32) + 7 * 4。



### 3.7.1. 直接访问别名区 (Directly accessing an alias region)

直接在别名区写入一个字等同于对位带区对应的 bit 位进行读-改-写操作。

在别名区域中写入字的值的 bit0 决定写入到位带区对应的 bit 位的值。bit0 为 1，则对应位带中的位写入 1，bit0 为 0，则对应位带中的位写入 0。

bit[31:1] 的值对位带区没有影响。即 写 0x01和写 0xFF 是同样的效果。写 0x0 和 0x0E 也是一样的效果。

读别名区的返回值只有 0x01 或 0x00。返回值为 0x01 则代表对应位带区的 bit 位被设置。返回值为 0x00 则代表对应位带区的 bit 位被清除。bit[31:1] 都是 0。



### 3.7.2. 直接访问位带区 (Directly accessing a bit-band region)

你可以使用对该区域的正常读写直接访问位带区域。



## 3.8. 处理器核心寄存器 (Processor core register summary)





















































