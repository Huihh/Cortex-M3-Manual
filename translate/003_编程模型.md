# 3. 编程模型 (Programmers Model)

该章节将介绍处理器编程模型。包含以下部分：

- 关于编程模型
- 操作模式和执行模式
- 指令集
- 系统地址映射
- 写缓冲区 (Write buffer)
- 位带 (Bit-banding)
- 处理器核心寄存器
- 异常



## 3.1. 关于编程模型 (About the programmers model)

**ARMv7-M Architecture Reference Manual** 中对编程模型进行完整的解释。本章概述实现定义选项的 Cortex-M3 处理器的程序模型。也包含 ARMv7-M Thumb 指令的使用和指令执行的周期。此外：

- 第四章节概述编程模型的系统控制特点。
- 第五章节概述编程模型的 MPU 特点。
- 第六章节概述编程模型的 NVIC 特点。
- 第七章节概述编程模型的 Debug 特点。
- 第八章节概述编程模型的 DWT 特点。
- 第九章节概述编程模型的 ITM 特点。
- 第十章节概述编程模型的 ETM 特点。
- 第十一章节概述编程模型的 TPIU 特点。



## 3.2. 操作模式和执行模式 (Modes of operation and execution)

该节简单描述 Cortex-M3 处理器的操作模式和执行模式。详见 **ARMv7-M Architecture Reference Manual** 。



### 3.2.1. 操作模式 (Operation modes)

处理器支持两种操作模式，分别为 **Thread** 模式 和 **Handler** 模式：

- 处理器在复位后，或异常返回后进入 **Thread** 模式。特权和用户代码都可以运行在 **Thread** 模式。
- 处理器在发生异常时进入 **Handler** 模式。在 **Handler** 模式中只能运行特权代码。



### 3.2.2.  操作状态 (Operating states)

处理器可以在以下两种状态中操作：

- **Thumb 状态**：用于正常执行 16-bit 和 32-bit 半字对齐的 **Thumb** 指令。
- **Debug 状态**：用于调试时停止处理器。



### 3.2.3. 特权访问和用户访问 (Privileged access and user access)

代码可以作为特权和非特权执行。非特权执行有一些限制或排除对某些资源的访问。特权执行可以访问所有资源。**Handler** 模式总是特权执行。**Thread** 模式可以是特权或非特权执行。



## 3.3. 指令集 (Instruction set summary)

分以下几点进行阐述：

- Cortex-M3 指令
- Load/store timings
- 与其它 Cortex 处理器的二进制兼容 (Binary compatibility with other Cortex processors)



### 3.3.1. Cortex-M3 指令 (Cortex-M3 instructions)

处理器实现了 ARMv7-M Thumb 指令集。下表 3-1 列出了 Cortex-M3 指令和各自的周期计数 (cycle counts)。周期计数基于系统处于零延时状态 (即理论值)。



汇编程序的语法中，是依赖于操作符，**\<op2>** 域可能会被以下选项中的任一种代替：

- 一个寄存器指示符，如：**Rm**
- 一个立即移位寄存器 (an immediate shifted register)，如：Rm, LSL #4
- 一个寄存器移位寄存器 (a register shifted register)，如： Rm, LSL Rs
- 一个立即数 (immediate value)，如：#0xE000E000



简单起见，并没有将所有的 load 和 store 地址模式全部显示。更多信息详见 **ARMv7-M Architecture Reference Manual** 。



表 3-1 周期列中的缩写含义如下：

| 值   | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| P    | 流水线再次填充所需要的周期数。依赖目标指令的宽度和对齐，以及处理器是否能够尽早推测出地址，范围为 1~3。 |
| B    | 执行屏蔽操作 (barrier operation) 所需要的周期数。对 DSB 和 DMB，最小周期数为 0。对于 ISB，最小周期数等于流水线再次填充所需要的周期数。 |
| N    | 要被加载或存储 (loaded or stored) 的寄存器列表中寄存器的个数，包括 PC 或 LR。 |
| W    | 等待适当事件所花费的周期数。                                 |
| a    | UMULL, SMULL, UMLAL 和 SMLAL 指令根据原始值大小使用提前终止。这些都是可中断的，被丢弃和重新启动的，最坏的情况下延迟一个周期。 |
| b    | 除法操作使用提前终止来根据输入操作数中的前导 1 和 0 的个数最小化所需的周期数。 |
| c    | 相邻的加载和存储单个指令可以通过管道 (pipeline) 传输它们的地址和数据阶段。他使这些指令能够在一个执行周期内完成。 |
| d    | 如果不接受条件分支，则条件分支将在一个周期内完成。           |
| e    | 可以将 IT 指令折叠到前面的 16-bit 的 Thumb 指令上，使其在 0 周期执行。 |



**表3-1 Cortex-M3 指令集**

| 操作码       | 类型                     | 汇编指令                    | 周期计数    |
| ------------ | ------------------------ | --------------------------- | ----------- |
| Move         | Register                 | MOV Rd, \<op2>              | 1           |
|              | 16-bit immediate         | MOVW Rd, #\<imm>            | 1           |
|              | Immediate into top       | MOVT Rd, #\<imm>            | 1           |
|              | To PC                    | MOV PC, Rm                  | 1 + P       |
| Add          | Add                      | ADD Rd, Rn, \<op2>          | 1           |
|              | Add to PC                | ADD PC, PC, Rm              | 1 + P       |
|              | Add with carry           | ADC Rd, Rn, \<op2>          | 1           |
|              | Form address             | ADR Rd, \<label>            | 1           |
| Subtract     | Subtract                 | SUB Rd, Rn, \<op2>          | 1           |
|              | Subtract with borrow     | SBC Rd, Rn, \<op2>          | 1           |
|              | Reverse                  | RSB Rd, Rn, \<op2>          | 1           |
| Multiply     | Multiply                 | MUL Rd, Rn, Rm              | 1           |
|              | Multiply accumulate      | MLA Rd, Rn, Rm              | 2           |
|              | Multiply subtract        | MLS Rd, Rn, Rm              | 2           |
|              | Long signed              | SMULL RdLo, RdHi, Rn, Rm    | 3 ~ 5a      |
|              | Long unsigned            | UMULL RdLo, RdHi, Rn, Rm    | 3 ~ 5a      |
|              | Long signed accumulate   | SMLAL RdLo, RdHi, Rn, Rm    | 4 ~ 7a      |
|              | Long unsigend accumulate | UMLAL RdLo, RdHi, Rn, Rm    | 4 ~ 7a      |
| Divide       | Signed                   | SDIV Rd, Rn, Rm             | 2 ~ 12b     |
|              | Unsigned                 | UDIV Rd, Rn, Rm             | 2 ~ 12b     |
| Saturate     | Signed                   | SSAT Rd, #\<imm>, \<op2>    | 1           |
|              | Unsigned                 | USAT Rd, #\<imm>, \<op2>    | 1           |
| Compare      | Compare                  | CMP Rn, \<op2>              | 1           |
|              | Negative                 | CMN Rn, \<op2>              | 1           |
| Logical      | AND                      | AND Rd, Rn, \<op2>          | 1           |
|              | Exclusive OR             | EOR Rd, Rn, \<op2>          | 1           |
|              | OR                       | ORR Rd, Rn, \<op2>          | 1           |
|              | OR NOT                   | ORN Rd, Rn, \<op2>          | 1           |
|              | Bit clear                | BIC Rd, Rn, \<op2>          | 1           |
|              | Move NOT                 | MVN Rd, \<op2>              | 1           |
|              | AND test                 | TST Rn, \<op2>              | 1           |
|              | Exclusive OR test        | TEQ Rn, \<op1>              |             |
| Shift        | Logical shift left       | LSL Rd, Rn, #\<imm>         | 1           |
|              | Logical shift left       | LSL Rd, Rn, Rs              | 1           |
|              | Logical shift right      | LSR Rd, Rn, #\<imm>         | 1           |
|              | Logical shift right      | LSR Rd, Rn, Rs              | 1           |
|              | Arithmetic shift right   | ASR Rd, Rn, #\<imm>         | 1           |
|              | Arithmetic shift right   | ASR Rd, Rn, Rs              | 1           |
| Rotate       | Rotate right             | ROR Rd, Rn, #\<imm>         | 1           |
|              | Rotate right             | ROR Rd, Rn, Rs              | 1           |
|              | With extension           | RRX Rd, Rn                  | 1           |
| Count        | Leading zeroes           | CLZ Rd, Rn                  | 1           |
| Load         | Word                     | LDR Rd, [Rn, \<op2>]        | 2c          |
|              | To PC                    | LDR PC, [Rn, \<op2>]        | 2c + P      |
|              | Halfword                 | LDRH Rd, [Rn, \<op2>]       | 2c          |
|              | Byte                     | LDRB Rd, [Rn, \<op2>]       | 2c          |
|              | Signed halfword          | LDRSH Rd, [Rn, \<op2>]      | 2c          |
|              | Signed byte              | LDRSB Rd, [Rn, \<op2>]      | 2c          |
|              | User word                | LDRT Rd, [Rn, #\<imm>]      | 2c          |
|              | User halfword            | LDRHT Rd, [Rn, #\<imm>]     | 2c          |
|              | User byte                | LDRBT Rd, [Rn, #\<imm>]     | 2c          |
|              | User signed halfword     | LDRSHT Rd, [Rn, #\<imm>]    | 2c          |
|              | User signed byte         | LDRSBT Rd, [Rn, #\<imm>]    | 2c          |
|              | PC relative              | LDR Rd, [PC, #\<imm>]       | 2c          |
|              | Doubleword               | LDRD Rd, Rd, [Rn, #\<imm>]  | 1 + N       |
|              | Multiple                 | LDM Rn, {\<reglist>}        | 1 + N       |
|              | Multiple including PC    | LDM Rn, {\<reglist>, PC}    | 1 + N + P   |
| Store        | Word                     | STR Rd, [Rn, \<op2>]        | 2c          |
|              | Halfword                 | STRH Rd, [Rn, \<op2>]       | 2c          |
|              | Byte                     | STRB Rd, [Rn, \<op2>]       | 2c          |
|              | Signed halfword          | STRSH Rd, [Rn, \<op2>]      | 2c          |
|              | Signed byte              | STRSB Rd, [Rn, \<op2>]      | 2c          |
|              | User word                | STRT Rd, [Rn, #\<imm>]      | 2c          |
|              | User halfword            | STRHT Rd, [Rn, #\<imm>]     | 2c          |
|              | User byte                | STRBT Rd, [Rn, #\<imm>]     | 2c          |
|              | User signed halfword     | STRSHT Rd, [Rn, #\<imm>]    | 2c          |
|              | User signed byte         | STRSBT Rd, [Rn, #\<imm>]    | 2c          |
|              | Doubleword               | STRD Rd, Rd, [Rn, #\<imm>]  | 1 + N       |
|              | Multiple                 | STM Rn, {\<reglist>}        | 1 + N       |
| Push         | Push                     | PUSH {\<reglist>}           | 1 + N       |
|              | Push with link register  | PUSH {\<register>, LR}      | 1 + N       |
| Pop          | Pop                      | POP {\<register>}           | 1 + N       |
|              | Pop and return           | POP {\<register>, PC}       | 1 + N + P   |
| Semaphore    | Load exclusive           | LDREX Rd, [Rn, #\<imm>]     | 2           |
|              | Load exclusive half      | LDREXH Rd, [Rn]             | 2           |
|              | Load exclusive byte      | LDREXB Rd, [Rn]             | 2           |
|              | Store exclusive          | STREX Rd, Rt, [Rn, #\<imm>] | 2           |
|              | Store exclusive half     | STREXH Rd, Rt, [Rn]         | 2           |
|              | Store exclusive byte     | STREXB Rd, Rt, [Rn]         | 2           |
|              | Clear exclusive monitor  | CLREX                       | 1           |
| Branch       | Conditional              | B\<cc> \<lable>             | 1 or 1 + Pd |
|              | Unconditional            | B \<lable>                  | 1 + P       |
|              | With link                | BL \<label>                 | 1 + P       |
|              | With exchange            | BX Rm                       | 1 + P       |
|              | With link and exchange   | BLX Rm                      | 1 + P       |
|              | Branch if zero           | CBZ Rn, \<label>            | 1 or 1 + Pd |
|              | Branch if non-zero       | CBNZ Rn, \<label>           | 1 or 1 + Pd |
|              | Byte table branch        | TBB [Rn, Rm]                | 2 + P       |
|              | Half table branch        | TBH [Rn, Rm, LSL#1]         | 2 + P       |
| State change | Supervisor call          | SVC #\<imm>                 | -           |
|              | If-then-else             | IT ... \<cond>              | 1e          |
|              | Disable interrupts       | CPSID \<flags>              | 1 or 2      |
|              | Enable interrupts        | CPSIE \<flags>              | 1 or 2      |
|              | Read special register    | MRS Rd, \<specreg>          | 1 or 2      |
|              | Write special register   | MSR \<specreg>, Rn          | 1 or 2      |
|              | Breakpoint               | BKPT #\<imm>                | -           |
| Extend       | Signed halfword to word  | SXTH Rd, \<op2>             | 1           |
|              | Signed byte to word      | SXTB Rd, \<op2>`            | 1           |

| 操作码    | 类型                        | 汇编指令                      | 周期计数 |
| --------- | --------------------------- | ----------------------------- | -------- |
| Extend    | Unsigned halfword           | UXTH Rd, \<op2>               | 1        |
|           | Unsigned byte               | UXTB Rd, \<op2>               | 1        |
| Bit field | Extract unsigned            | UBFX Rd, Rn, #\<imm>, #\<imm> | 1        |
|           | Extract signed              | SBFX Rd, Rn, #\<imm>, #\<imm> | 1        |
|           | Clear                       | BFC Rd, Rn, #\<imm>, #\<imm>  | 1        |
|           | Insert                      | BFI Rd, Rn, #\<imm>, #\<imm>  | 1        |
| Reverse   | Bytes in word               | REV Rd, Rm                    | 1        |
|           | Bytes in both halfwords     | REV16 Rd, Rm                  | 1        |
|           | Signed bottom halfword      | REVSH Rd, Rm                  | 1        |
|           | Bits in word                | RBIT Rd, Rm                   | 1        |
| Hint      | Send event                  | SEV                           | 1        |
|           | Wait for event              | WFE                           | 1 + W    |
|           | Wait for interrupt          | WFI                           | 1 + W    |
|           | No operation                | NOP                           | 1        |
| Barriers  | Instruction synchronization | ISB                           | 1 + B    |
|           | Data memory                 | DMB                           | 1 + B    |
|           | Data synchronization        | DSB \<flags>                  | 1 + B    |



### 3.3.2. 加载/存储计时 (Load/store timings)

以下将描述如何最佳地对指令进行配对，以实现更多的时间缩减：

- **STR Rx, [Ry, #imm]** 总是一个周期，这是因为地址产生是在最初的周期 (initial cycle) 中被执行的，数据存储是在执行下一条指令的同时执行的。如果存储到缓冲区，但缓冲区已满或者没有被使能，则下一条指令将被延迟，直到存储完成。如果不是存储到缓冲区，列如：对于 **Code segment** 和事务停止，只有在完成之前执行另一个加载或存储操作时，才会感觉到对时间的影响。
- **LDR Rx!, [any]** 不是一般的流水线。也就是说，基于更新加载通常至少是2个周期的操作(如果停止，则更多)。但是，如果下一条指令不需要从寄存器中读取，那么加载就会减少到一个周期。非寄存器写指令包括 CMP、TST、NOP 和non-taken IT controlled 指令。
- **LDR PC, [any]** 总是一个阻塞的操作。这意味着至少有两个周期用于加载，三个周期用于流水线重新加载。因此，这个操作至少需要五个周期，如果在加载或取指时阻塞则需要更多。
- **LDR Rx, [PC, #imm]** 可能会由于与取指单元的争用而增加一个周期。
- **TBB 和 TBH** 也是阻塞操作。至少有两个周期用于加载，一个周期用于添加，三个周期用于流水线重新加载。因此，这个操作至少需要六个周期，如果在加载或取指时阻塞则需要更多。
- 











































