# 7. 调试 (Debug)

该章节描述如何调试和测试处理器上运行的软件程序。包括以下部分：

- 关于调试
- 关于 AHB-AP
- 关于闪存补丁和断点单元 (FPB: Flash Patch and Breakpoint Unit) 



## 7.1. 关于调试 (About debug)

处理器实现决定调试配置，包括是否实现调试。如果处理器没有实现调试，则不存在 **ROM table** ，停止 (halt)，断点，观察点功能也都不存在。

基本的调试功能包括停止处理器 (processor halt)，单步 (single-step)，访问处理器核心寄存器 (processor core register access)，捕获向量 (Vector Catch)，无限的软件断点 (unlimited software breakpoints) 和访问整个系统内存 (full system memory access)。详细信息参见 **RMv7-M Architectural Reference Manual** 。

调试选项可能包括：

- 一个断点单元，支持 2 个常量比较器 (literal comparators) 和 6 个指令比较器 (instruction comparators)，或者只支持 2 个指令比较器。
- 支持 1 个或 4 个观察点的观察点单元 (a watchpoint unit supporting 1 or 4 watchpoints)。



对于实现了调试的处理器，ARM 建议调试器使用 CoreSight 调试基础设施识别并连接到调试组件。

图7-1显示了调试器可以遵循的建议流程，以发现 CoreSight 调试基础结构中的组件。在这种情况下，调试器将读取 CoreSight 系统中每个 CoreSight 组件的外围设备和组件 ID 寄存器。

![](E:\Work\ARM\pictures\Chapter 7\Snipaste_2019-07-10_14-41-34.png)



为了在 CoreSight 系统中识别 Cortex-M3 处理器，ARM 建议调试器执行以下操作：

1. 使用 Cortex-M3 ROM 表的 CoreSight 标识来定位和标识它。详见 7.1.1. 小节。
2. 遵循 Cortex-M3 ROM 表中的指针：
   1. 系统控制空间 (SCS: System Control Space)
   2. 断点单元(BPU: Breakpoint unit)
   3. 数据观察点单元 (DWT: Data watchpint unit)



当调试器根据其自己的 CoreSight 标识 识别了 SCS 时，它可以从位于地址 0xE000_ED00 的 SCS 中的CPUID 寄存器中识别处理器及其修订号。



调试器不能依赖于遇到的第一个 ROM 表就是 Cortex-M3 ROM 表。如果系统中有其他 CoreSight 组件，则在访问端口和 Cortex-M3 ROM 表之间需要一个或多个系统 ROM 表。如果存在系统 ROM 表，则包含实现的唯一标识符。



### 7.1.1. Cortex-M3 ROM 表识别和条目 (Cortex-M3 ROM table identification and entries)

表 7-1 列出了用于调试器检测的 ROM 表标识寄存器和值。这允许调试器识别处理器及其调试功能。

**注：Cortex-M3 ROM 表只支持字大小传输访问** 。

![](E:\Work\ARM\pictures\Chapter 7\Snipaste_2019-07-10_15-06-05.png)

表 7-2 显示了 Cortex-M3 ROM 表指向的 CoreSight 组件。这些值取决于实现的调试配置。

| 地址        | 组件          | 值          | 描述                                                         |
| ----------- | ------------- | ----------- | ------------------------------------------------------------ |
| 0xE00F_F000 | SCS           | 0xFFF0_F003 | 见 7.1.2 小节                                                |
| 0xE00F_F004 | DWT           | 0xFFF0_2003 | 见 8.3 小节                                                  |
| 0xE00F_F008 | FPB           | 0xFFF0_3003 | 见 7.3.2 小节                                                |
| 0xE00F_F00C | ITM           | 0xFFF0_1003 | 见 9.3 小节                                                  |
| 0xE00F_F010 | TPIU          | 0xFFF4_1003 | 见 11.3 小节                                                 |
| 0xE00F_F014 | ETM           | 0xFFF4_2003 | 见第 10 章节                                                 |
| 0xE00F_F018 | End marker    | 0x0000_0000 | 见 **DAP accessible ROM table in the ARMv7-M Architectural Reference Manual** |
| 0xE00F_FFCC | SYSTEM ACCESS | 0x0000_0001 | 见 **DAP accessible ROM table in the ARMv7-M Architectural Reference Manual** |

注：

- 如果 DWT 没有实现，读则返回 0xFFF0_2002 。
- 如果 FPB 没有实现，读则返回 0xFFF0_3002 。
- 如果 ITM 没有实现，读则返回 0xFFF0_1002 。
- 如果 TPIU 没有实现，读则返回 0xFFF4_1002 。
- 如果 ETM 没有实现，读则返回 0xFFF4_2002 。



ROM 表条目指向处理器的调试组件。每个条目的偏移量是组件基于 ROM 表基地址 0xE00F_F000 的偏移。

参阅 **ARMv7-M Architectural Reference Manual** 和 **ARM CoreSight Components Technical Reference Manual** 获取有关 ROM 表 ID 和组件寄存器及其地址和访问类型的更多信息。



### 7.1.2. 系统控制空间 (System Control Space)

如果实现了调试，处理器将通过 SCS 中的寄存器提供调试。见：

- 调试寄存器 (见7.1.3 小节)
- 系统地址映射 (见 3.4 小节)



**SCS CoreSight identification**

表 7-3 显示用于调试器检测的 SCS CoreSight 标识寄存器和值。最终调试器是通过 SCS 中的 CPUID 寄存器来识别 Cortex-M3 处理器的。(CPUID 寄存器见 4.3.2 小节)

![](E:\Work\ARM\pictures\Chapter 7\Snipaste_2019-07-10_16-05-47.png)



参阅 **ARMv7-M Architectural Reference Manual** 和 **ARM CoreSight Components Technical Reference Manual** 获取有关 SCS CoreSight 标识寄存器及其地址和访问类型的更多信息。



### 7.1.3. 调试寄存器 (Debug register summary)

下表列出了调试寄存器。每个寄存器都是 32 位宽度，其在 **ARMv7-M Architectural Reference Manual** 中描述。

| 地址        | 名称  | 类型 | 复位值      | 描述                                                         |
| ----------- | ----- | ---- | ----------- | ------------------------------------------------------------ |
| 0xE000_ED30 | DFSR  | RW   | 0x0000_0000 | 调试 Fault 状态寄存器 (Debug Fault Status Register)          |
| 0xE000_EDF0 | DHCSR | RW   | 0x0000_0000 | 调试停止控制和状态寄存器 (Debug Halting Control and Status Register) |
| 0xE000_EDF4 | DCRSR | WO   | -           | 调试内核寄存器选择器寄存器 (Debug Core Register Selector Register) |
| 0xE000_EDF8 | DCRDR | RW   | -           | 调试内核寄存器数据寄存器 (Debug Core Register Data Register) |
| 0xE000_EDFC | DEMCR | RW   | 0x0000_0000 | 调试异常和监控控制寄存器 (Debug Exception and Monitor Control Register) |



内核调试是个可选的组件。如果移除了内核调试，则停止模式 (halt mode) 调试将不被支持，将不能停止，单步，或寄存器传输功能。调试监督模式 (monitor mode) 仍然被支持。



## 7.2. 关于 AHB-AP (About the AHB-AP)

AHB-AP 是在 **ARM Debug Interface v5 Architecture Specification** 中定义的一个内存访问端口 (MEM-AP: Memory Access Port)。在 Cortex-M3 系统中，AHB-AP 是一个可选的调试访问端口，用于提供访问所有的内存和系统中的寄存器，包括通过 SCS 访问处理器的寄存器。系统访问与处理器状态无关。使用 SW-DP 或 SWJ-DP 访问 AHB-AP。



AHB-AP 作为是总线矩阵 (Bus Matrix) 的主端。事务使用 AHB-AP 编程模型生成，该模型将 AHB-Lite 事务传输到总线矩阵中。



### 7.2.1. AHB-AP 事务类型 (AHB-AP transcation types)

AHB-AP 在总线上不执行背靠背 (back-to-back) 事务，因此所有事务都是非顺序 (non-sequential) 的。AHB-AP 可以执行非对齐和位带事务。总线矩阵处理这些。AHB-AP 事务不受 MPU 查找的约束。AHB-AP 事务绕过 FPB，因此 FPB 无法重新映射 AHB-AP 事务。

AHB-AP 事务是小端。



### 7.2.2. AHB-AP 编程模型 (AHB-AP programmers model)

表 7-5 列出了 AHB-AP 的寄存器。如果 AHB-AP 不存在，则读这些寄存器将返回 0。读此表中未指定的任何寄存器将返回零。

![](E:\Work\ARM\pictures\Chapter 7\Snipaste_2019-07-10_16-39-03.png)



这里只描述 AHB-AP 特定于这个处理器实现的寄存器。其它的寄存器在 **CoreSight Components Technical Reference Manual** 中描述。



AHB-AP Control and Status Word Register, CSW

CSW 寄存器特点如下：

- 目的：配置和控制通过 AHB 接口事务传输。
- 用法限制：没有。
- 配置：在所有处理器配置中该寄存器都是有效的。
- 属性：如下表所示。

![](E:\Work\ARM\pictures\Chapter 7\Snipaste_2019-07-10_16-47-56.png)

| 位      | 名称        | 功能                                                         |
| ------- | ----------- | ------------------------------------------------------------ |
| [31:30] | -           | 保留，读返回 b00。                                           |
| [29]    | MasterType  | 0 = core。                                                                                                                           1 = debug。                                                                                                                 如果事务未完成，该位不能修改。调试器必须先检查 bit[7] 位(TransInProg)。                                                                                                               复位值为 0b1。                                                                                                          实现可以将此位配置为只读值为 1。这种情况下，事务总是显示为 debug。 |
| [28:26] | -           | 保留，0b000。                                                |
| [25]    | Hprot1      | 用户和特权控制 - HPROT[1]。                                                                                      复位值为 0b1。 |
| [24]    | -           | 保留，0b1。                                                  |
| [23:12] | -           | 保留，0x000。                                                |
| [11:8]  | Mode        | 操作模式位：                                                                                                                   b0000 = 普通下载和上传模式。                                                                                                               b0001 - b1111 保留。                                                                                                复位值为 0b0000。 |
| [7]     | TransInProg | 处理的事务。这个字段表示在 AHB 主端口是否有事务在处理。      |
| [6]     | DbgStatus   | 表示 DAPEN 端口的状态：                                                                                                           1 = AHB 允许传输。                                                                                                        0 = AHB 不允许传输。 |
| [5:4]   | AddrInc     | 读取或写入数据访问时自动增加地址和打包模式 (pack mode)。仅当当前事务没有错误完成时才递增。                                                                                          访问存储数据寄存器 0x10 - 0x1C时，不会执行自动地址递增和打包传输。这种情况下忽略该字段。                                                                                                    增量和封装在 4KB 的地址范围内，例如：从 0x1000 到 0x1FFC。如果起始为 0x14A0，如果计数增加到 0x1FFC，再回到 0x1000，然后继续增加到 0x149C。                                                                                                                       0b00 = 自动增加关闭。                                                                                            0b01 = 增量单次。从对应的字节巷 (byte lane) 进行单次传输。                                           0b10 = 增加打包 (increment packed)                                                                          0b11 = 保留。没有传输                                                                                           地址增加的大小取决于 [2:0] 位的值。                                                                        复位值为 0b00。 |
| [3]     | -           | 保留                                                         |
| [2:0]   | Size        | 访问大小字段：                                                                                                            b000 = 8 位                                                                                                                       b001 = 16 位                                                                                                                       b010 = 32 位                                                                                                                 b011 - b111 保留                                                                                                          复位值为 0b000。 |



## 7.3. 关于闪存补丁和断点单元, FPB (About Flash Patch and Breakpoint Unit)

FPB：

- 实现了硬件断点。
- 从代码空间到系统空间的补丁代码和数据。

一个完整的 FPB 单元包括：

- 两个常量 (literal) 比较器，用于匹配从代码空间加载的常量 (literal load from Code space)，并重新映射到系统空间的相应区域。
- 六个指令比机器，用于匹配从代码空间取得的指令，并重新映射到系统空间的相应区域。或者，你可以单独配置比较器，以便在匹配时向处理器内核返回断点指令 (BKPT: Breakpoint Instruction)，以提供硬件断点功能。

简化后的 FPB 单元包含：

- 两个指令比较器。你可以单独配置比较器，以便在匹配时向处理器内核返回断点指令 (BKPT: Breakpoint Instruction)，以提供硬件断点功能。




### 7.3.1. FPB 功能描述 (FPB functional description)

FPB 包含的 8 个比较器可以使用全局启用和单独启用。如果有条目匹配成功，则地址为：

- 映射到重映射寄存器中设置的地址，加上与匹配的比较器对应的偏移量。
- 如果特性使能，重映射到一个断点指令 (BKPT) 。

比较是动态进行的，如果比较结果发生太晚以至于无法停止从代码空间获取原始指令或常量加载 (literal load) 。从而，处理器会忽略这个事务，只使用重新映射的事务。

如果 MPU 存在，MPU 执行查找原始地址，而不是重映射地址。



如果不需要调试，你可以移除 FPB，或你可以将它支持的断点数量减少到 2 个。如果 PFB 仅支持 2 个断点，则只有比较器 0 和比较器 1 可以使用，FPB 不支持闪存补丁 (flash patching) 。

注：

- 非对齐的常量访问 (literal accesses) 不会被重新映射。这种情况下，对 DCode 总线的原始访问发生。
- 加载独占访问可以被重新映射。然而，它们是否作为独占访问执行是不可预测 (UNPREDICTABLE) 的。
- 不支持将闪存补丁 (flash remap) 重新映射到位带别名 (bit-land alias)，会导致不可预知 (UNPREDICTABLE ) 的行为。



### 7.3.2. FPB 编程模型 (FPB programmers model)

表 7-7 列出了 FPB 的寄存器。依赖你的处理器的实现，其中有些可能不存在。读取不存在的寄存器返回 0。

| 地址        | 名称     | 类型 | 复位值 | 描述                                                     |
| ----------- | -------- | ---- | ------ | -------------------------------------------------------- |
| 0xE000_2000 | FP_CTRL  | RW   | 0x130  | 闪存补丁控制寄存器 (FlashPatch Control Register)         |
| 0xE000_2004 | FP_REMAP | RW   | -      | 闪存补丁重映射寄存器 (FlashPatch Remap Registe)          |
| 0xE000_2008 | FP_COMP0 | RW   | 1'b0   | 闪存补丁比较器寄存器0 (FlashPatch Comparator Register0)  |
| 0xE000_200C | FP_COMP1 | RW   | 1'b0   | 闪存补丁比较器寄存器1 (FlashPatch Comparator Register1)  |
| 0xE000_2010 | FP_COMP2 | RW   | 1'b0   | 闪存补丁比较器寄存器2 (FlashPatch Comparator Register2)  |
| 0xE000_2014 | FP_COMP3 | RW   | 1'b0   | 闪存补丁比较器寄存器3 (FlashPatch Comparator Register3)  |
| 0xE000_2018 | FP_COMP4 | RW   | 1'b0   | 闪存补丁比较器寄存器4 (FlashPatch Comparator Register4)  |
| 0xE000_201C | FP_COMP5 | RW   | 1'b0   | 闪存补丁比较器寄存器5 (FlashPatch Comparator Register5)  |
| 0xE000_2020 | FP_COMP6 | RW   | 1'b0   | 闪存补丁比较器寄存器6 (FlashPatch Comparator Register6)  |
| 0xE000_2024 | FP_COMP7 | RW   | 1'b0   | 闪存补丁比较器寄存器7 (FlashPatch Comparator Register7)  |
| 0xE000_2FD0 | PID4     | RO   | 0x04   | 外设身份识别寄存器 (Peripheral identification registers) |
| 0xE000_2FD4 | PID5     | RO   | 0x00   | 同上                                                     |
| 0xE000_2FD8 | PID6     | RO   | 0x00   | 同上                                                     |
| 0xE000_2FDC | PID7     | RO   | 0x00   | 同上                                                     |
| 0xE000_2FE0 | PID0     | RO   | 0x03   | 同上                                                     |
| 0xE000_2FE4 | PID1     | RO   | 0xB0   | 同上                                                     |
| 0xE000_2FE8 | PID2     | RO   | 0x2B   | 同上                                                     |
| 0xE000_2FEC | PID3     | RO   | 0x00   | 同上                                                     |
| 0xE000_2FF0 | CID0     | RO   | 0x0D   | 容器身份识别寄存器 (Component identification registers)  |
| 0xE000_2FF4 | CID1     | RO   | 0xE0   | 同上                                                     |
| 0xE000_2FF8 | CID2     | RO   | 0x05   | 同上                                                     |
| 0xE000_2FFC | CID3     | RO   | 0xB1   | 同上                                                     |

FPB 的所有寄存器在 **ARMv7-M Architecture Reference Manual** 中描述。